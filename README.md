# -*- coding: utf-8 -*-
"""Estrutura de Dados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iaRqP3RrnDRAMXV3RlAA-0_gBhW5VZEg

# **Algoritmo Bubble Sort**

# **Algoritmo Insertion Sort**

# **Algoritmo Selection Sort**

# **Algoritmo Quick Sort**

# **Algoritmo Quick Sort**

**1. Conceitos Básicos:**
   - **Divisão e Conquista:**
     - Explicar o princípio da estratégia "dividir para conquistar".
     - Destacar como o Quick Sort utiliza esse princípio para ordenar uma lista.

**2. Funcionamento do Quick Sort:**
   - **Escolha do Pivô:**
     - Explicar o conceito do pivô e sua seleção.
     - Destacar a importância de escolher um pivô eficiente para garantir a eficácia do algoritmo.

   - **Particionamento:**
     - Demonstrar como a lista é particionada em torno do pivô.
     - Ilustrar a divisão da lista em duas partes: elementos menores que o pivô e elementos maiores que o pivô.

   - **Recursividade:**
     - Explicar como o Quick Sort é aplicado recursivamente nas duas sub-listas geradas pelo particionamento.
     - Enfatizar a divisão contínua até que todas as sub-listas se tornem unidades ordenadas.

**3. Implementação:**
   - Apresentar um exemplo prático de implementação do algoritmo Quick Sort em pseudocódigo ou em uma linguagem de programação como Java ou Python.
   - Destacar as partes-chave, incluindo a escolha do pivô, o particionamento e a recursividade.

```java
public class QuickSort {
    public static void quickSort(int[] array, int inicio, int fim) {
        if (inicio < fim) {
            int indicePivo = particionar(array, inicio, fim);
            quickSort(array, inicio, indicePivo - 1);
            quickSort(array, indicePivo + 1, fim);
        }
    }

    private static int particionar(int[] array, int inicio, int fim) {
        int pivô = array[fim];
        int i = inicio - 1;

        for (int j = inicio; j < fim; j++) {
            if (array[j] <= pivô) {
                i++;
                trocar(array, i, j);
            }
        }

        trocar(array, i + 1, fim);
        return i + 1;
    }

    private static void trocar(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    // Exemplo de utilização
    public static void main(String[] args) {
        int[] array = {12, 4, 5, 6, 7, 3, 1, 15, 8, 10};
        int n = array.length;

        quickSort(array, 0, n - 1);

        System.out.println("Array ordenado: " + Arrays.toString(array));
    }
}
```

**4. Análise de Complexidade:**
   - Apresentar a análise de complexidade do Quick Sort, destacando seu desempenho médio e pior caso.
   - Comparar com outros algoritmos de ordenação em termos de eficiência.

**5. Conclusão:**
   - Recapitular os principais pontos abordados na aula.
   - Destacar a eficiência do Quick Sort e sua aplicabilidade em cenários práticos.
   - Incentivar os alunos a explorarem implementações e variações do algoritmo para um entendimento mais profundo.

## **Passo a passo da aplicação a uma lista de inteiros com 10 elementos**

Vamos passar por um exemplo passo a passo da aplicação do algoritmo Quick Sort a uma lista de inteiros com 10 elementos. Para este exemplo, consideraremos a seguinte lista:

$[12, 4, 5, 6, 7, 3, 1, 15, 8, 10]$

**Passo 1: Escolha do Pivô**
- Vamos escolher o último elemento como pivô. Portanto, $pivo = 10$ .

**Passo 2: Particionamento**
- Vamos percorrer a lista da esquerda para a direita, comparando cada elemento com o pivô.
  - $[12, 4, 5, 6, 7, 3, 1, 15, 8, \textbf{10}]$
  - Movemos $\textbf{4}$ para a esquerda, pois é menor que o pivô.

- Continuamos o particionamento:
  - $[12, \textbf{4}, 5, 6, 7, 3, 1, 15, 8, \textbf{10}] $
  - $\textbf{5}$ é menor que o pivô, então movemos $\textbf{5}$ para a esquerda.

  - $ [12, 4, \textbf{5}, 6, 7, 3, 1, 15, 8, \textbf{10}] $
  - $\textbf{6} $ é menor que o pivô, então movemos $\textbf{6} $ para a esquerda.

  - $[12, 4, 5, \textbf{6}, 7, 3, 1, 15, 8, \textbf{10}] $
  - $\textbf{7} $ é menor que o pivô, então movemos $\textbf{7} $ para a esquerda.

  - $[12, 4, 5, 6, \textbf{7}, 3, 1, 15, 8, \textbf{10}] $
  - $\textbf{3} $ é menor que o pivô, então movemos $\textbf{3} $ para a esquerda.

  - $[12, 4, 5, 6, 7, \textbf{3}, 1, 15, 8, \textbf{10}] $
  - $\textbf{1} $ é menor que o pivô, então movemos $\textbf{1} $ para a esquerda.

  - $[12, 4, 5, 6, 7, 3, \textbf{1}, 15, 8, \textbf{10}] $
  - $\textbf{8} $ é maior que o pivô, então não precisa ser movido.

  - $[12, 4, 5, 6, 7, 3, 1, 15, \textbf{8}, \textbf{10}] $
  - $\textbf{15} $ é maior que o pivô, então não precisa ser movido.

  - $[12, 4, 5, 6, 7, 3, 1, \textbf{15}, \textbf{8}, \textbf{10}] $
  - $\textbf{10} $ é maior que o pivô, então não precisa ser movido.

- Agora, trocamos o pivô ($\text{pivô} = 10 $) com o primeiro elemento maior que o pivô na lista, que é $\text{8} $.
  - $[8, 4, 5, 6, 7, 3, 1, 10, 15] $

**Passo 3: Aplicação Recursiva**
- Aplicamos recursivamente o Quick Sort nas duas sub-listas geradas pelo particionamento:
  - Sub-lista à esquerda de $\text{pivô} = 8 $: $[4, 5, 6, 7, 3, 1] $
  - Sub-lista à direita de $\text{pivô} = 8 $: $[10, 15] $

**Passo 4: Particionamento (Sub-lista à Esquerda)**
- Escolhemos o último elemento como pivô novamente ($\text{pivô} = 1 $).
- Particionamos a sub-lista à esquerda:
  - $[\textbf{1}, 5, 6, 7, 3, \textbf{4}] $
  - $[\textbf{1}, \textbf{3}, 6, 7, \textbf{4}, \textbf{5}] $

**Passo 5: Aplicação Recursiva (Sub-lista à Esquerda)**
- Aplicamos recursivamente o Quick Sort na sub-lista à esquerda:
  - Sub-lista à esquerda de $\text{pivô} = 3 $: $[1] $
  - Sub-lista à direita de $\text{pivô} = 3 $: $[4, 5] $

**Passo 6: Particionamento (Sub-lista à Direita)**
- Escolhemos o único elemento como pivô ($\text{pivô} = 5 $).
- Particionamos a sub-lista à direita:
  - $[4, \textbf{5}] $

**Passo 7: Aplicação Recursiva (Sub-lista à Direita)**
- Como a sub-lista à direita tem apenas dois elementos, não precisamos realizar mais particionamentos.

**Passo 8: Resultado Final**
- Juntamos todas as sub-listas ordenadas para obter o resultado final:
  - $[1, 3, 4, 5, 6, 7, 8, 10, 15] $

Este é o processo do Quick Sort aplicado a uma lista de 10 elementos. O algoritmo continua a ser aplicado recursivamente até que todas as sub-listas tenham apenas um elemento, resultando em uma lista totalmente ordenada.

# **Algoritmo de busca binária**

* O algoritmo de busca binária é executado somente em vetores ordenados. Nesse algoritmo o vetor com os dados é dividido ao meio e o número do meio é comparado com o número procurado.

* Se estes forem iguais, a busca termina, caso contrário, se o número procurado é menor que o do meio, a busca será realizada no vetor à esquerda ao do meio.

* Se o número procurado é maior que o do meio, a busca será realizada no vetor à direita ao vetor do meio. Esse procedimento de divisão e comparação acontece até que o vetor de dados fique com apenas um elemento ou até o número procurado
ser encontrado.

```java
public class busca_binaria {
	public static void main(String[] args) {
		int[] x = {1,2,3,4,5,6,7,8,9,10};
		int tamanho = x.length;
    //numero buscado
		int np = 4;

		//buscando o numero
		int achou = 0;
		int inicio = 0;
		int fim = tamanho - 1;
		int meio = (inicio+fim)/2;

		while(inicio <= fim && achou == 0) {
			if (x[meio] == np) {
				achou = 1;
			} else {
				if (np < x[meio])
					fim = meio - 1;
				else
					inicio = meio + 1;
				meio = (inicio + fim)/2;
			}
		}

		if (achou == 0) {
			System.out.println("Número não encontrado");
		} else {
			System.out.println("Número encontrado no index "+meio);
		}
	}
}
```

# **Algoritmo de ordenação Heap Sort**

Este algoritmo de ordenação é baseado na estrutura de dados `HEAP`, que nada mais é do que um vetor (X) que pode ser visto como uma árvore binária completa, onde cada nó possui no máximo 2 filhos. Cada vértice da árvore corresponde a um elemento do vetor. A árvore é completamente preenchida exceto no último nível. Cada nível é sempre preenchido da direita para a esquerda. Além disso, num HEAP, para todo vértice i diferente da raiz, a seguinte propriedade deve ser válida:` X[Pai(i)] > X[i]`.

Dado um índice i do vetor, para se descobrir as posições em que se encontram o seu pai, o filho esquerdo e o direito, realizam-se os cálculos:
* `Pai(i) = i/2,`
* `Filho Esquerdo(i) = 2*i e `
* `Filho Direito(i) =2*i + 1`.


```java
import java.util.Scanner;

public class heap_sort {
	static int x[] = new int[11];
	static Scanner entrada = new Scanner(System.in);
	public static void main(String[] args) {
		int i;
		int qtde = 10;
		for (i = 1; i <= 10; i++) {
			System.out.println("Digite o numero: ");
			x[i] = entrada.nextInt();
		}
		/*transformando o vetor digitado em um heap
		 * cada no pai é maior que seus filhos
		 * */

		transforma_heap(qtde);
		//ordena de forma crescente
		ordena(qtde);
		for (i = 1; i <= 10; i++) {
			System.out.println(i+" numero: "+ x[i]);
		}
	}

	public static void transforma_heap(int qtde) {
		int i;
		for (i = qtde/2; i >= 1; i--) {
			heap_fica(i, qtde);
		}
	}

	private static void heap_fica(int i, int qtde) {
		int f_esq, f_dir, maior, aux;
		maior = i;
		if(2*i+1<=qtde) {
			/* o no que está sendo analisado
			 * tem filhos para esquerda e direita
			 * */
			f_esq = 2*i+1;
			f_dir = 2*i;

			if(x[f_esq] >= x[f_dir] && x[f_esq] > x[i]) {
				maior = 2*i+1;
			}else if(x[f_dir] > x[f_esq] && x[f_dir] > x[i]){
				maior = 2*i;
			}
		}else if(2*i <= qtde) {
			/*o no que esta sendo analisado tem filho
			 * apenas para a direita
			 * */
			f_dir = 2*i;
			if(x[f_dir] > x[i])
				maior = 2* i;
		}

		if(maior != i) {
			aux = x[i];
			x[i] = x[maior];
			x[maior] = aux;
			heap_fica(maior, qtde);
		}

	}

	private static void ordena(int qtde) {
		int i, aux, ultima_posi;
		for (i = qtde; i >= 2; i--) {
			aux = x[1];
			x[1]=x[i];
			x[i]=aux;
			ultima_posi = i-1;
			heap_fica(1, ultima_posi);
		}

	}
}

```

Vamos passar pelo algoritmo `Heap Sort` passo a passo usando o vetor dado `[8, 3, 9, 5, 2, 4]`.
"""

# Começamos a transformação do heap a partir do meio do vetor (índice 3).


      8
     / \
    5   4
   / \ / \
  3  2 9

# Trocamos o primeiro elemento (raiz do heap) com o último elemento do heap não
# ordenado e ajustamos o heap. 8 (antes) <-> 4 (último).

      4
     / \
    5   9
   / \ / \
  3  2 8

#Agora, repetimos o passo para o restante do heap não ordenado (índices 1 a 4).

      5
     / \
    4   9
   / \ / \
  3  2 8

2
     / \
    4   9
   / \ / \
  3  5 8

#Repetimos os passos até que todo o vetor seja ordenado.

"""Suponha que você tenha um conjunto de números representando alturas de pessoas em centímetros e deseja ordenar essas alturas em ordem crescente. Vamos usar o Heap Sort para realizar essa tarefa.

```java
import java.util.Arrays;
import java.util.Scanner;

public class AlturasSort {
    static int alturas[] = new int[11];
    static Scanner entrada = new Scanner(System.in);

    public static void main(String[] args) {
        int qtde = 6;  // Número de alturas a serem inseridas
        lerAlturas(qtde); // Ler as alturas
        transformaHeap(qtde); // Transformar as alturas em um heap
        ordenaHeap(qtde); // Ordenar as alturas usando Heap Sort
        exibirAlturas(qtde); // Exibir as alturas ordenadas
    }

    public static void lerAlturas(int qtde) {
        System.out.println("Digite " + qtde + " alturas em centímetros:");
        for (int i = 1; i <= qtde; i++) {
            System.out.print("Altura " + i + ": ");
            alturas[i] = entrada.nextInt();
        }
    }

    public static void transformaHeap(int qtde) {
        for (int i = qtde / 2; i >= 1; i--) {
            heapify(i, qtde);
        }
    }

    private static void heapify(int i, int qtde) {
        int leftChild = 2 * i;
        int rightChild = 2 * i + 1;
        int largest = i;

        if (leftChild <= qtde && alturas[leftChild] > alturas[largest]) {
            largest = leftChild;
        }

        if (rightChild <= qtde && alturas[rightChild] > alturas[largest]) {
            largest = rightChild;
        }

        if (largest != i) {
            swap(i, largest);
            heapify(largest, qtde);
        }
    }

    private static void swap(int i, int j) {
        int temp = alturas[i];
        alturas[i] = alturas[j];
        alturas[j] = temp;
    }

    private static void ordenaHeap(int qtde) {
        for (int i = qtde; i >= 2; i--) {
            swap(1, i);
            qtde--;
            heapify(1, qtde);
        }
    }

    public static void exibirAlturas(int qtde) {
        System.out.println("Alturas ordenadas:");
        for (int i = 1; i <= qtde; i++) {
            System.out.println(i + " altura: " + alturas[i] + " cm");
        }
    }
}


```

# Estutura de dados do tipo listas

# Estrutura de dados do tipo pilha e fila

# Estrutura de dados do tipo lista de prioridades

# Estrutura de dados do tipo *`hashing`*

# Estrutura de dados do tipo árvore

As estruturas de dados do tipo árvore são não lineares, ou seja, os elementos que as compõem não estão armazenados de forma sequencial e também não estão todos encadeados.

`Desenho`

## Árvore binária

Uma árvore binária é um conjunto finito de elementos, onde cada elemento é denominado nó e o primeiro é conhecido como raiz da árvore. Esse conjunto pode estar vazio ou ser particionado em três subconjuntos distintos, sendo eles:

* **1º subconjunto (nó raiz);**
* **2º subconjunto (sub-árvore direita);** e
* **3º subconjunto (sub-árvore esquerda).**

`Desenho`

As árvores binárias podem ser ilustradas de três formas distintas:

`Desenho`

Toda árvore binária possui as seguintes propridades:

1. Todos os nós de uma sub-árvore direita são maiores que o nó raiz.
2. Todos os nós de uma sub-árvore esquerda são menores que o nó raiz.
3. Cada sub-árvore é também uma árvore binária.
4. O grau de um nó representa o seu número de sub-árvores.

`Desenho`

5. Em uma árvore binária, o grau máximo de um nó é 2.

6. O grau de uma árvore é igual ao máximo dos graus de todos os seus nós.

7. Uma árvore binária tem grau máximo igual a 2.

8. Nó pai, nó acima e com ligação direta a outro nó.

9. Nó filho, nó abaixo e com ligação direta a outro nó. São os nós raízes das sub-árvores.

10. Nós irmãos, são os nós que possuem o mesmo nó pai.

11. Nó folha ou terminal, nó que não possui filhos.

`Desenho`

12. Nó ancestral, são os nós que estão ancima de um nó e possuem ligação direta ou indireta.

13. Nós descendentes, são nós que estão abixo de um nó e possuem ligação direta ou indireta.

14. Nós descendentes direto, são nós que estão abaixo de um nó, possuem ligação direta ou indireta e fazem parte da sub-árvore direita.

15. Nós descendentes esquerdo, são os nós que estão abaixo de um nó, posuem ligação direta ou indireta e fazem parte da sub-árvore esquerda.

16. Nível de um nó, é a sua distância do nó raiz. Logo, o nível do nó raiz é sempre zero.

17. Altura ou profundidade de uma árvore, é o nível do nó mais distante da raiz.

`Desenho`

18. Expressão que representa o número máximo de nós em umnível da árvore binária  $= 2^n$ onde $n$ é o nível em questão.

`Desenho`

19. Árvore estritamente bínaria, é a árvore em que todos os nós têm 0 ou 2 filhos.

20. Expressão que representa o número de nós de uma árvore estritamente binária $= 2n-1$, onde $n$ é o número de nós folha.

`Desenho`

21. Árvore completa, é a árvore em que todos os nós com menos de dois filhos ficam no último e no penúltimo nível.

21. Árvore cheia, é a árvore estritamente binária e completa.

`Desenho`

Neste tipo de estrutura serão abordadas as seguintes operações:

* inserir um nó na árvore removê-lo;
* consultar os nós da árvore em ordem;
* consultar em pré-ordem;
* consultar em pós-ordem; e
* esvaziar a árvore.


### Na operação de inserção
As propriedades de uma árvore devem ser obedecidas e todo novo nó é sempre uma folha.

### Na operação de remoção
O filho da direita, que é o mais velho, assume o lugar do nó pai.

### Nas operações de consulta
Em ordem, pré-ordem e pós-ordem, todos os nós da árvore são listados, alterando-se apenas sua ordem.

1. Na consulta em ordem

Cada árvore é mostrada com o ramo da esquerda, a raiz e posteriormente o ramo da direita.

2. Na consulta pré-ordem

Cada árvore é mostrada com a raiz, o ramo da esquerda e posteriormente o ramo da direita.

3. Na consulta pós-ordem

Cada árvore é mostrada com o ramo da esquerda, o ramo da direita e posteriormente a raiz.


`Desenho`

Aqui está um pseudocódigo da função `insert` para inserir um novo valor em uma árvore binária:

```
função insert(valor)
    se raiz for nula:
        criar um novo nó com o valor
        definir o novo nó como raiz
    senão:
        definir current como raiz
        definir parent como nulo
        enquanto current não for nulo:
            definir parent como current
            se valor for menor que current.valor:
                definir current como o filho esquerdo de current
            senão se valor for maior que current.valor:
                definir current como o filho direito de current
            senão:
                // Valor já existe na árvore, não faz nada
                retornar
        // Chegamos a um nó nulo, vamos inserir o novo valor
        criar um novo nó com o valor
        se valor for menor que parent.valor:
            definir o novo nó como filho esquerdo de parent
        senão:
            definir o novo nó como filho direito de parent
fim da função
```

Este pseudocódigo descreve o processo de inserção de um novo valor em uma árvore binária. Ele percorre a árvore começando pela raiz, comparando o valor a ser inserido com o valor de cada nó para decidir em qual direção navegar. Quando encontramos um nó nulo, sabemos que encontramos o local de inserção e criamos um novo nó com o valor fornecido. Este novo nó é então adicionado como filho do último nó visitado.
"""

import java.util.Scanner;

public class arvore_binaria {

	private static class ARVORE{
		public int num;
		public ARVORE dir, esq;
	}

	private static class PILHA{
		public ARVORE num;
		public PILHA prox;
	}

	public static void main(String[] args) {
		menu();
	}

	//funcao menu
	public static void menu() {
		ARVORE raiz = null;
		ARVORE aux = null;
		ARVORE aux1;
		ARVORE novo = null;
		ARVORE anterior;
		PILHA topo;
		PILHA aux_pilha;
		Scanner entrada = new Scanner(System.in);
		int op, achou, numero;

		do {
			System.out.println("\t Menu de Opções \n");
			System.out.println("\t 1-Inserir na árvore");
			System.out.println("Digite sua opção: \n");
			op = entrada.nextInt();
			if(op == 1) {
				inserir_no(raiz, novo, aux, entrada);
			}
		}while(op != 8);
	}

	//funcao inserir no na arvore
	public static void inserir_no(ARVORE raiz, ARVORE novo, ARVORE aux, Scanner entrada) {
		int achou =0;
		System.out.println("Digite o número a ser inserido na árvore:");
		novo = new ARVORE();
		novo.num = entrada.nextInt();
		novo.dir = null;
		novo.esq = null;
		if(raiz == null)
			raiz = novo;
		else {
			aux = raiz;
			achou = 0;
			while(achou == 0) {
				if(novo.num < aux.num) {
					if(aux.esq == null) {
						aux.esq = novo;
						achou = 1;
					}else aux = aux.esq;
				}else if(novo.num >= aux.num) {
					if(aux.dir == null) {
						aux.dir = novo;
						achou = 1;
					}else aux = aux.dir;
				}
			}
		}
	}

}

"""
## Árvore Binária

Uma árvore binária é uma estrutura de dados em que cada nó tem no máximo dois filhos, chamados de filho esquerdo e filho direito. Cada nó contém um valor e referências para seus filhos. No código fornecido, temos a classe `TreeNode` que representa um nó da árvore. Cada nó possui um valor (`val`) e referências para seus filhos esquerdo (`left`) e direito (`right`).

### Inserção na Árvore Binária

A inserção em uma árvore binária envolve encontrar o local correto para inserir um novo valor e adicioná-lo como um novo nó na árvore. Aqui está o passo a passo da função `insert`:

1. **Verificação da Raiz**: Primeiro, verificamos se a árvore está vazia. Se estiver, o novo valor se torna a raiz da árvore.
2. **Navegação na Árvore**: Se a árvore não estiver vazia, iniciamos a navegação na árvore a partir da raiz. Começamos com `current` apontando para a raiz e `parent` como nulo.
3. **Localização do Local de Inserção**: Enquanto `current` não for nulo, comparamos o valor a ser inserido (`val`) com o valor do nó atual (`current.val`). Se o valor a ser inserido for menor que o valor do nó atual, movemos para o filho esquerdo (`current.left`). Se for maior, movemos para o filho direito (`current.right`). Mantemos o nó pai (`parent`) atualizado para o nó anterior antes de mover para o próximo nível.
4. **Inserção do Novo Nó**: Quando encontramos um nó nulo (ou seja, não há mais nós a percorrer na direção em que estamos indo), sabemos que encontramos o local de inserção. Criamos um novo nó com o valor a ser inserido e o adicionamos como filho do nó pai no lado correspondente (esquerdo ou direito), dependendo da comparação feita anteriormente.
5. **Tratamento de Duplicatas**: Se o valor a ser inserido já estiver presente na árvore, não fazemos nada (não permitimos duplicatas na árvore).

### Exemplo de Utilização

No exemplo fornecido no método `main`, criamos uma instância da classe `BinaryTree` e inserimos os valores 5, 3, 8, 2, 4, 7 e 9. Isso resulta em uma árvore binária com a seguinte estrutura:

```
       5
      / \
     3   8
    / \ / \
   2  4 7  9
```

Cada nó da árvore é representado pelo seu valor, e as linhas conectam os nós pai aos seus filhos. Esta é uma representação visual da árvore resultante após a inserção dos valores.
"""

//outra versao

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
        left = null;
        right = null;
    }
}

public class BinaryTree {
    private TreeNode root;

    public BinaryTree() {
        root = null;
    }

    public void insert(int val) {
        if (root == null) {
            root = new TreeNode(val);
            return;
        }

        TreeNode current = root;
        TreeNode parent = null;

        while (current != null) {
            parent = current;
            if (val < current.val) {
                current = current.left;
            } else if (val > current.val) {
                current = current.right;
            } else {
                // O valor já existe na árvore, então não fazemos nada
                return;
            }
        }

        if (val < parent.val) {
            parent.left = new TreeNode(val);
        } else {
            parent.right = new TreeNode(val);
        }
    }

    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(5);
        tree.insert(3);
        tree.insert(8);
        tree.insert(2);
        tree.insert(4);
        tree.insert(7);
        tree.insert(9);

        // Após a inserção, a árvore deve ter a seguinte estrutura:
        //       5
        //      / \
        //     3   8
        //    / \ / \
        //   2  4 7  9
    }
}

"""Em resumo, a função `insert` navega pela árvore binária até encontrar o local correto para inserir o novo valor e o adiciona como um novo nó na árvore. Este processo é feito de forma iterativa, sem a necessidade de recursão.

Aqui está um pseudocódigo para o método de busca (search) em uma árvore binária:

```
função busca(valor):
    // Comece a busca a partir da raiz da árvore
    nó_atual = raiz
    
    // Enquanto não alcançarmos uma folha
    enquanto nó_atual não for nulo faça:
        // Se o valor atual é o valor que estamos procurando, retorne verdadeiro
        se valor é igual a nó_atual.valor então
            retorne verdadeiro
        
        // Se o valor é menor que o valor do nó atual, vá para a subárvore esquerda
        senão, se valor é menor que nó_atual.valor então
            nó_atual = nó_atual.esquerda
        // Caso contrário, vá para a subárvore direita
        senão:
            nó_atual = nó_atual.direita
    
    // Se chegamos aqui, o valor não foi encontrado na árvore, então retorne falso
    retorne falso
```

Este pseudocódigo descreve um algoritmo recursivo de busca binária em uma árvore binária de busca (BST). Ele começa da raiz e compara o valor que estamos procurando com o valor do nó atual. Se forem iguais, encontramos o valor e retornamos verdadeiro. Se o valor for menor, continuamos a busca na subárvore esquerda; caso contrário, continuamos na subárvore direita. Se alcançarmos uma folha (nó atual se torna nulo) sem encontrar o valor, retornamos falso.
"""

public boolean search(int val) {
        TreeNode current = root;

        while (current != null) {
            if (val == current.val) {
                return true;
            } else if (val < current.val) {
                current = current.left;
            } else {
                current = current.right;
            }
        }

        return false;
    }

public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(5);
        tree.insert(3);
        tree.insert(8);
        tree.insert(2);
        tree.insert(4);
        tree.insert(7);
        tree.insert(9);

        // Consultando valores na árvore
        System.out.println(tree.search(3)); // Deve imprimir true
        System.out.println(tree.search(6)); // Deve imprimir false
    }

"""A função `search` é implementada sem utilizar recursão. Ela realiza a busca do valor na árvore, percorrendo-a iterativamente a partir da raiz. Se o valor for encontrado, a função retorna `true`, caso contrário, retorna `false`.

Antes de iniciarmos os métodos de consultas na árvore é importante entender uma biblioteca relevante que irá ajudar nosso trabalho, que é a `Stack`.

* [Como trabalhar com a classe Stack
](https://www.devmedia.com.br/como-trabalhar-com-a-classe-stack/2966)

* [Quick Guide to the Java Stack](https://www.baeldung.com/java-stack)

Para consultar toda a árvore em ordem (in-order traversal), podemos usar uma abordagem iterativa sem recursão, utilizando uma pilha para simular o processo de recursão. Aqui está a implementação atualizada:
"""

import java.util.Stack;
...

public void inOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;

        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            current = stack.pop();
            System.out.print(current.val + " ");
            current = current.right;
        }
    }
  ...

"""Nesta implementação, a função `inOrderTraversal()` consulta toda a árvore em ordem, começando pelo nó raiz. Utilizamos uma pilha (`Stack`) para armazenar os nós visitados. O algoritmo segue estas etapas:

1. Inicializamos uma pilha e definimos um ponteiro `current` para o nó raiz.
2. Enquanto `current` não for nulo ou a pilha não estiver vazia:
   - Percorremos todos os nós à esquerda, empilhando cada nó visitado.
   - Quando alcançamos o nó mais à esquerda, não há mais nós à esquerda para percorrer. Então, retiramos o nó do topo da pilha, o visitamos e avançamos para seu filho direito (se existir).
3. Repetimos o processo até que todos os nós tenham sido visitados e processados em ordem crescente.

Para consultar toda a árvore em pré-ordem (pre-order traversal), também podemos usar uma abordagem iterativa sem recursão, utilizando uma pilha para simular o processo de recursão. Aqui está a implementação atualizada:
"""

import java.util.Stack;
//...
    public void preOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        while (!stack.isEmpty()) {
            TreeNode current = stack.pop();
            System.out.print(current.val + " ");

            if (current.right != null) {
                stack.push(current.right);
            }
            if (current.left != null) {
                stack.push(current.left);
            }
        }
    }
//...

//...
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(5);
        tree.insert(3);
        tree.insert(8);
        tree.insert(2);
        tree.insert(4);
        tree.insert(7);
        tree.insert(9);

        // Consultando toda a árvore em pré-ordem
        tree.preOrderTraversal(); // Deve imprimir: 5 3 2 4 8 7 9
    }

"""Nesta implementação, a função `preOrderTraversal()` consulta toda a árvore em pré-ordem, começando pelo nó raiz. Utilizamos uma pilha (`Stack`) para armazenar os nós visitados. O algoritmo segue estas etapas:

1. Inicializamos uma pilha e empilhamos o nó raiz.
2. Enquanto a pilha não estiver vazia:
   - Retiramos o nó do topo da pilha, o visitamos e o desempilhamos.
   - Se o nó tiver um filho direito, o empilhamos.
   - Se o nó tiver um filho esquerdo, o empilhamos (antes do filho direito para que seja visitado primeiro).
3. Repetimos o processo até que todos os nós tenham sido visitados e processados em pré-ordem.

Para consultar toda a árvore em pós-ordem (post-order traversal), também podemos usar uma abordagem iterativa sem recursão, utilizando uma pilha para simular o processo de recursão. Aqui está a implementação atualizada:
"""

public void postOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(root);

        while (!stack1.isEmpty()) {
            TreeNode current = stack1.pop();
            stack2.push(current);

            if (current.left != null) {
                stack1.push(current.left);
            }
            if (current.right != null) {
                stack1.push(current.right);
            }
        }

        while (!stack2.isEmpty()) {
            System.out.print(stack2.pop().val + " ");
        }
    }

public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(5);
        tree.insert(3);
        tree.insert(8);
        tree.insert(2);
        tree.insert(4);
        tree.insert(7);
        tree.insert(9);

        // Consultando toda a árvore em pós-ordem
        tree.postOrderTraversal(); // Deve imprimir: 2 4 3 7 9 8 5
    }

"""Nesta implementação, a função `postOrderTraversal()` consulta toda a árvore em pós-ordem, começando pelo nó raiz. Utilizamos duas pilhas (`Stack`) para armazenar os nós visitados. O algoritmo segue estas etapas:

1. Inicializamos duas pilhas (`stack1` e `stack2`) e empilhamos o nó raiz em `stack1`.
2. Enquanto `stack1` não estiver vazia:
   - Retiramos o nó do topo de `stack1`, o visitamos e o empilhamos em `stack2`.
   - Se o nó tiver um filho direito, o empilhamos em `stack1`.
   - Se o nó tiver um filho esquerdo, o empilhamos em `stack1`.
3. Após percorrer toda a árvore, desempilhamos os elementos de `stack2` para imprimir os valores em pós-ordem.

## Juntando todas as funções

````java
package arvore;

import java.util.Stack;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
        left = null;
        right = null;
    }
}

public class BinaryTree {
    private TreeNode root;

    public BinaryTree() {
        root = null;
    }

    public void insert(int val) {
        if (root == null) {
            root = new TreeNode(val);
            return;
        }

        TreeNode current = root;
        TreeNode parent = null;

        while (current != null) {
            parent = current;
            if (val < current.val) {
                current = current.left;
            } else if (val > current.val) {
                current = current.right;
            } else {
                // O valor já existe na árvore, então não fazemos nada
                return;
            }
        }

        if (val < parent.val) {
            parent.left = new TreeNode(val);
        } else {
            parent.right = new TreeNode(val);
        }
    }

    public boolean search(int val) {
        TreeNode current = root;

        while (current != null) {
            if (val == current.val) {
                return true;
            } else if (val < current.val) {
                current = current.left;
            } else {
                current = current.right;
            }
        }

        return false;
    }

    public void inOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;

        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            current = stack.pop();
            System.out.print(current.val + " ");
            current = current.right;
        }
    }

    public void preOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        while (!stack.isEmpty()) {
            TreeNode current = stack.pop();
            System.out.print(current.val + " ");

            if (current.right != null) {
                stack.push(current.right);
            }
            if (current.left != null) {
                stack.push(current.left);
            }
        }
    }

    public void postOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(root);

        while (!stack1.isEmpty()) {
            TreeNode current = stack1.pop();
            stack2.push(current);

            if (current.left != null) {
                stack1.push(current.left);
            }
            if (current.right != null) {
                stack1.push(current.right);
            }
        }

        while (!stack2.isEmpty()) {
            System.out.print(stack2.pop().val + " ");
        }
    }

    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(5);
        tree.insert(3);
        tree.insert(8);
        tree.insert(2);
        tree.insert(4);
        tree.insert(7);
        tree.insert(9);

        // Consultando valores na árvore
        System.out.println(tree.search(3)); // Deve imprimir true
        System.out.println(tree.search(6)); // Deve imprimir false
        // Consultando toda a árvore em ordem
        tree.inOrderTraversal(); // Deve imprimir: 2 3 4 5 7 8 9
        System.out.println();
        // Consultando toda a árvore em pré-ordem
        tree.preOrderTraversal(); // Deve imprimir: 5 3 2 4 8 7 9
        System.out.println();
        // Consultando toda a árvore em pós-ordem
        tree.postOrderTraversal(); // Deve imprimir: 2 4 3 7 9 8 5
    }
}

```
"""

package arvore;

import java.util.Stack;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
        left = null;
        right = null;
    }
}

public class BinaryTree {
    private TreeNode root;

    public BinaryTree() {
        root = null;
    }

    public void insert(int val) {
        if (root == null) {
            root = new TreeNode(val);
            return;
        }

        TreeNode current = root;
        TreeNode parent = null;

        while (current != null) {
            parent = current;
            if (val < current.val) {
                current = current.left;
            } else if (val > current.val) {
                current = current.right;
            } else {
                // O valor já existe na árvore, então não fazemos nada
                return;
            }
        }

        if (val < parent.val) {
            parent.left = new TreeNode(val);
        } else {
            parent.right = new TreeNode(val);
        }
    }

    public boolean search(int val) {
        TreeNode current = root;

        while (current != null) {
            if (val == current.val) {
                return true;
            } else if (val < current.val) {
                current = current.left;
            } else {
                current = current.right;
            }
        }

        return false;
    }

    public void inOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;

        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            current = stack.pop();
            System.out.print(current.val + " ");
            current = current.right;
        }
    }

    public void preOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        while (!stack.isEmpty()) {
            TreeNode current = stack.pop();
            System.out.print(current.val + " ");

            if (current.right != null) {
                stack.push(current.right);
            }
            if (current.left != null) {
                stack.push(current.left);
            }
        }
    }

    public void postOrderTraversal() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(root);

        while (!stack1.isEmpty()) {
            TreeNode current = stack1.pop();
            stack2.push(current);

            if (current.left != null) {
                stack1.push(current.left);
            }
            if (current.right != null) {
                stack1.push(current.right);
            }
        }

        while (!stack2.isEmpty()) {
            System.out.print(stack2.pop().val + " ");
        }
    }

    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(5);
        tree.insert(3);
        tree.insert(8);
        tree.insert(2);
        tree.insert(4);
        tree.insert(7);
        tree.insert(9);

        // Consultando valores na árvore
        System.out.println(tree.search(3)); // Deve imprimir true
        System.out.println(tree.search(6)); // Deve imprimir false
        // Consultando toda a árvore em ordem
        tree.inOrderTraversal(); // Deve imprimir: 2 3 4 5 7 8 9
        System.out.println();
        // Consultando toda a árvore em pré-ordem
        tree.preOrderTraversal(); // Deve imprimir: 5 3 2 4 8 7 9
        System.out.println();
        // Consultando toda a árvore em pós-ordem
        tree.postOrderTraversal(); // Deve imprimir: 2 4 3 7 9 8 5
    }
}

"""Ainda podem ser inseridos outros métodos como valor mínimo e valor máximo"""

public int findMin() {
        TreeNode current = root;
        while (current.left != null) {
            current = current.left;
        }
        return current.val;
    }

    public int findMax() {
        TreeNode current = root;
        while (current.right != null) {
            current = current.right;
        }
        return current.val;
    }

public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(5);
        tree.insert(3);
        tree.insert(8);
        tree.insert(2);
        tree.insert(4);
        tree.insert(7);
        tree.insert(9);

        // Consultando toda a árvore em pré-ordem
        tree.preOrderTraversal(); // Deve imprimir: 5 3 2 4 8 7 9

        // Encontrando o valor mínimo e máximo na árvore
        System.out.println("\nValor mínimo na árvore: " + tree.findMin()); // Deve imprimir: 2
        System.out.println("Valor máximo na árvore: " + tree.findMax()); // Deve imprimir: 9
    }

"""Métodos excluir


* Se z não tem nenhum filho, então simplesmente o removemos modificando seu pai de modo a substituir z por NIL como seu filho.

* Se o nó tem apenas um filho, então elevamos esse filho para que ocupe a posição de z na árvore modificando o pai de z de modo a substituir z pelo filho de z.

* Se z tiver dois filhos, encontramos o sucessor de z, y, que deve estar na subárvore direita de z, e obrigamos y a tomar a posição de z na árvore. O resto da subárvore direita original de z tornase a nova subárvore direita de y, e a subárvore esquerda de z tornase a nova subárvore esquerda de y. Esse é o caso complicado porque, como veremos, o fato de y ser ou não o filho à direita de z é importante.

**Caso contrário**

* Se z não tiver nenhum filho à esquerda (parte (a) da figura), substituímos z por seu filho à direita, que pode ser ou não NIL. Quando o filho à direita de z é NIL, esse caso trata da situação na qual z não tem nenhum filho. Quando o filho à direita de z é não NIL, esse caso manipula a situação na qual z tem somente um filho, que é o seu filho à
direita.

* Se z tiver apenas um filho, que é o seu filho à esquerda (parte (b) da Figura), substituímos z por seu filho à esquerda.

* Caso contrário, z tem um filho à esquerda e também um filho à direita. Encontramos o sucessor de z, y, que está na subárvore direita de z e não tem nenhum filho à esquerda. Queremos recortar y de sua localização atual e fazêlo substituir z na árvore.  

1. Se y é o filho à direita de z (parte (c)), substituímos z por y, deixando o filho à direita de y sozinho.

2. Caso contrário, y encontrase dentro da subárvore direita de z, mas não é o filho à direita de z (parte (d)). **OBS.** Nesta situação o nó removido deve ser substituído pelo no mais a esquerda da sub-árvore da direita. Nesse caso, primeiro substituímos y por seu próprio filho à direita e depois substituímos z por y.


"""

delete(node, value):
    // Caso base: se a árvore está vazia
    se node é nulo:
        retornar node

    // Se o valor a ser excluído é menor que o valor do nó atual,
    // devemos procurar na subárvore esquerda
    se value < node.value:
        node.left = delete(node.left, value)

    // Se o valor a ser excluído é maior que o valor do nó atual,
    // devemos procurar na subárvore direita
    senão se value > node.value:
        node.right = delete(node.right, value)

    // Se o valor a ser excluído é igual ao valor do nó atual,
    // então encontramos o nó que queremos excluir
    senão:
        // Caso 1: Nó a ser excluído é um nó folha (sem filhos)
        se node.left é nulo e node.right é nulo:
            liberar a memória alocada para node
            node = null

        // Caso 2: Nó a ser excluído tem apenas um filho
        senão se node.left é nulo:
            temp = node.right
            liberar a memória alocada para node
            retornar temp
        senão se node.right é nulo:
            temp = node.left
            liberar a memória alocada para node
            retornar temp

        // Caso 3: Nó a ser excluído tem dois filhos
        // Encontrar o sucessor in-order (nó mais à esquerda na subárvore direita)
        temp = findMin(node.right)
        // Copiar o valor do sucessor para o nó a ser excluído
        node.value = temp.value
        // Excluir o sucessor
        node.right = delete(node.right, temp.value)

    retornar node

"""Colocando o mais profundo a esquerda como sucessor do no deletado."""

public void delete(int val) {
	    Stack<TreeNode> stack = new Stack<>();
	    TreeNode current = root;
	    TreeNode parent = null;

	    // Encontrar o nó a ser excluído e seu pai
	    while (current != null && current.val != val) {
	        parent = current;
	        if (val < current.val) {
	            stack.push(current);
	            current = current.left;
	        } else {
	            stack.push(current);
	            current = current.right;
	        }
	    }

	    if (current == null) {
	        // O nó não foi encontrado na árvore
	        return;
	    }

	    if (current.left == null && current.right == null) {
	        // Caso 1: Nó a ser excluído é um nó folha (sem filhos)
	        if (parent == null) {
	            // O nó a ser excluído é a raiz da árvore
	            root = null;
	        } else if (parent.left == current) {
	            parent.left = null;
	        } else {
	            parent.right = null;
	        }
	    } else if (current.left == null || current.right == null) {
	        // Caso 2: Nó a ser excluído tem apenas um filho
	        TreeNode child = (current.left != null) ? current.left : current.right;
	        if (parent == null) {
	            // O nó a ser excluído é a raiz da árvore
	            root = child;
	        } else if (parent.left == current) {
	            parent.left = child;
	        } else {
	            parent.right = child;
	        }
	    } else {
	        // Caso 3: Nó a ser excluído tem dois filhos
	        TreeNode successor = current.left;
	        TreeNode successorParent = current;
	        while (successor.right != null) {
	            stack.push(successorParent);
	            successorParent = successor;
	            successor = successor.right;
	        }
	        current.val = successor.val;
	        if (successorParent == current) {
	            current.left = successor.left;
	        } else {
	            successorParent.right = successor.left;
	        }
	    }
	}

"""Colocando o mais profundo a direita como sucessor do no deletado."""

public void delete(int val) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode current = root;
    TreeNode parent = null;

    // Encontrar o nó a ser excluído e seu pai
    while (current != null && current.val != val) {
        parent = current;
        if (val < current.val) {
            stack.push(current);
            current = current.left;
        } else {
            stack.push(current);
            current = current.right;
        }
    }

    if (current == null) {
        // O nó não foi encontrado na árvore
        return;
    }

    if (current.left == null && current.right == null) {
        // Caso 1: Nó a ser excluído é um nó folha (sem filhos)
        if (parent == null) {
            // O nó a ser excluído é a raiz da árvore
            root = null;
        } else if (parent.left == current) {
            parent.left = null;
        } else {
            parent.right = null;
        }
    } else if (current.left == null || current.right == null) {
        // Caso 2: Nó a ser excluído tem apenas um filho
        TreeNode child = (current.left != null) ? current.left : current.right;
        if (parent == null) {
            // O nó a ser excluído é a raiz da árvore
            root = child;
        } else if (parent.left == current) {
            parent.left = child;
        } else {
            parent.right = child;
        }
    } else {
        // Caso 3: Nó a ser excluído tem dois filhos
        TreeNode successor = current.right;
        TreeNode successorParent = current;
        while (successor.left != null) {
            stack.push(successorParent);
            successorParent = successor;
            successor = successor.left;
        }
        current.val = successor.val;
        if (successorParent == current) {
            current.right = successor.right;
        } else {
            successorParent.left = successor.right;
        }
    }
}

public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(5);
        tree.insert(3);
        tree.insert(8);
        tree.insert(2);
        tree.insert(4);
        tree.insert(7);
        tree.insert(9);

        // Consultando toda a árvore em ordem
        System.out.println("Árvore antes da exclusão:");
        tree.inOrderTraversal(); // Deve imprimir: 2 3 4 5 7 8 9

        // Excluindo um nó da árvore
        tree.delete(3);

        // Consultando toda a árvore em ordem após a exclusão
        System.out.println("\nÁrvore após a exclusão:");
        tree.inOrderTraversal(); // Deve imprimir: 2 4 5 7 8 9
    }

"""```java
package arvore;
import java.util.Stack;


//outra versao

class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  public TreeNode(int val) {
      this.val = val;
      left = null;
      right = null;
  }
}

public class BinaryTree {
  private TreeNode root;

  public BinaryTree() {
      root = null;
  }

  public void insert(int val) {
      if (root == null) {
          root = new TreeNode(val);
          return;
      }

      TreeNode current = root;
      TreeNode parent = null;

      while (current != null) {
          parent = current;
          if (val < current.val) {
              current = current.left;
          } else if (val > current.val) {
              current = current.right;
          } else {
              // O valor já existe na árvore, então não fazemos nada
              return;
          }
      }

      if (val < parent.val) {
          parent.left = new TreeNode(val);
      } else {
          parent.right = new TreeNode(val);
      }
  }
  
  public boolean search(int val) {
      TreeNode current = root;

      while (current != null) {
          if (val == current.val) {
              return true;
          } else if (val < current.val) {
              current = current.left;
          } else {
              current = current.right;
          }
      }

      return false;
  }
  
  public void inOrderTraversal() {
      if (root == null) {
          return;
      }

      Stack<TreeNode> stack = new Stack<>();
      TreeNode current = root;

      while (current != null || !stack.isEmpty()) {
          while (current != null) {
              stack.push(current);
              current = current.left;
          }
          
          current = stack.pop();
          System.out.print(current.val + " ");
          current = current.right;
      }
  }
  

  public void preOrderTraversal() {
      if (root == null) {
          return;
      }

      Stack<TreeNode> stack = new Stack<>();
      stack.push(root);

      while (!stack.isEmpty()) {
          TreeNode current = stack.pop();
          System.out.print(current.val + " ");

          if (current.right != null) {
              stack.push(current.right);
          }
          if (current.left != null) {
              stack.push(current.left);
          }
      }
  }
  
  public void postOrderTraversal() {
      if (root == null) {
          return;
      }

      Stack<TreeNode> stack1 = new Stack<>();
      Stack<TreeNode> stack2 = new Stack<>();
      stack1.push(root);

      while (!stack1.isEmpty()) {
          TreeNode current = stack1.pop();
          stack2.push(current);

          if (current.left != null) {
              stack1.push(current.left);
          }
          if (current.right != null) {
              stack1.push(current.right);
          }
      }

      while (!stack2.isEmpty()) {
          System.out.print(stack2.pop().val + " ");
      }
  }
  
  public void delete(int val) {
	    Stack<TreeNode> stack = new Stack<>();
	    TreeNode current = root;
	    TreeNode parent = null;

	    // Encontrar o nó a ser excluído e seu pai
	    while (current != null && current.val != val) {
	        parent = current;
	        if (val < current.val) {
	            stack.push(current);
	            current = current.left;
	        } else {
	            stack.push(current);
	            current = current.right;
	        }
	    }

	    if (current == null) {
	        // O nó não foi encontrado na árvore
	        return;
	    }

	    if (current.left == null && current.right == null) {
	        // Caso 1: Nó a ser excluído é um nó folha (sem filhos)
	        if (parent == null) {
	            // O nó a ser excluído é a raiz da árvore
	            root = null;
	        } else if (parent.left == current) {
	            parent.left = null;
	        } else {
	            parent.right = null;
	        }
	    } else if (current.left == null || current.right == null) {
	        // Caso 2: Nó a ser excluído tem apenas um filho
	        TreeNode child = (current.left != null) ? current.left : current.right;
	        if (parent == null) {
	            // O nó a ser excluído é a raiz da árvore
	            root = child;
	        } else if (parent.left == current) {
	            parent.left = child;
	        } else {
	            parent.right = child;
	        }
	    } else {
	        // Caso 3: Nó a ser excluído tem dois filhos
	        TreeNode successor = current.left;
	        TreeNode successorParent = current;
	        while (successor.right != null) {
	            stack.push(successorParent);
	            successorParent = successor;
	            successor = successor.right;
	        }
	        current.val = successor.val;
	        if (successorParent == current) {
	            current.left = successor.left;
	        } else {
	            successorParent.right = successor.left;
	        }
	    }
	}


  public static void main(String[] args) {
      BinaryTree tree = new BinaryTree();
      tree.insert(5);
      tree.insert(3);
      tree.insert(8);
      tree.insert(2);
      tree.insert(4);
      tree.insert(7);
      tree.insert(9);
      
      // Consultando valores na árvore
      System.out.println(tree.search(3)); // Deve imprimir true
      System.out.println(tree.search(6)); // Deve imprimir false
      // Após a inserção, a árvore deve ter a seguinte estrutura:
      //       5
      //      / \
      //     3   8
      //    / \ / \
      //   2  4 7  9
      // Consultando toda a árvore em ordem
      tree.inOrderTraversal(); // Deve imprimir: 2 3 4 5 7 8 9
      System.out.println();
      // Consultando toda a árvore em pré-ordem
      tree.preOrderTraversal(); // Deve imprimir: 5 3 2 4 8 7 9
      System.out.println();
  	  // Consultando toda a árvore em pós-ordem
      tree.postOrderTraversal(); // Deve imprimir: 2 4 3 7 9 8 5
      System.out.println();
      // Excluindo um nó da árvore
      tree.delete(3);
      // Consultando toda a árvore em pré-ordem
      tree.preOrderTraversal(); // Deve imprimir: 5 3 2 4 8 7 9
      System.out.println();
  }
}

```

## Árvore AVL
"""



"""# Algotirmos em grafos

**Grafo:** Um grafo \( G \) é uma estrutura composta por um conjunto de vértices (ou nós) \( V \) e um conjunto de arestas \( E \). As arestas conectam pares de vértices. Os grafos podem ser representados de várias formas, como listas de adjacência ou matrizes de adjacência.

**Tipos de Grafos:**
1. **Grafo Não Direcionado:** As arestas não têm direção. Se existe uma aresta entre \( A \) e \( B \), ela pode ser percorrida de \( A \) para \( B \) e vice-versa.
2. **Grafo Direcionado (Digrafo):** As arestas têm direção. Uma aresta de \( A \) para \( B \) só pode ser percorrida de \( A \) para \( B \).
3. **Grafo Ponderado:** As arestas têm um peso associado. Isso é usado para representar custos, distâncias ou qualquer outra métrica.
4. **Grafo Completo:** Cada par de vértices distintos está conectado por uma aresta.
5. **Grafo Conexo:** Existe um caminho entre qualquer par de vértices.

**Terminologia:**
- **Vértices (nós):** Os pontos de um grafo.
- **Arestas (edges):** As linhas que conectam os vértices.
- **Grau de um vértice:** Número de arestas conectadas a ele.
- **Caminho:** Uma sequência de arestas que conecta um conjunto de vértices.
- **Ciclo:** Um caminho que começa e termina no mesmo vértice sem repetir arestas.

### Aplicações Reais de Grafos

1. **Redes Sociais:**
   - Representar usuários como vértices e amizades/conexões como arestas.
   - Análise de redes sociais (SNA) para descobrir influenciadores, comunidades e padrões de interação.

2. **Roteamento e Navegação:**
   - GPS e sistemas de navegação usam grafos para encontrar rotas mais curtas entre locais.
   - Algoritmos como Dijkstra e A* são usados para calcular o caminho mais curto.

3. **Redes de Computadores:**
   - Representar a topologia de uma rede com dispositivos como vértices e conexões de rede como arestas.
   - Otimização de roteamento de dados e detecção de falhas.

4. **Biologia Computacional:**
   - Modelagem de redes de interação proteína-proteína.
   - Análise de sequências de DNA usando grafos de de Bruijn para montagem de genomas.

5. **Engenharia de Software:**
   - Dependências de módulos de software representadas por grafos direcionados.
   - Análise de fluxo de controle em programas.

6. **Planejamento de Projetos:**
   - Grafos de precedência em diagramas de Gantt para gerenciar dependências de tarefas.
   - Algoritmos de caminho crítico (CPM) para otimização de cronogramas.

7. **Pesquisa Operacional:**
   - Modelagem de problemas de transporte e logística.
   - Resolução de problemas de fluxo de rede, como o problema do fluxo máximo.

8. **Análise de Dados e Machine Learning:**
   - Redes neurais representadas como grafos acíclicos direcionados.
   - Algoritmos de clusterização em grafos para detecção de grupos e padrões.

### Algoritmos Comuns em Grafos

1. **Busca em Profundidade (DFS) e Busca em Largura (BFS):**
   - Exploração de todos os vértices e arestas de um grafo.
   - Utilizados para detecção de ciclos, conectividade e caminhos.

2. **Dijkstra:**
   - Encontra o caminho mais curto de um vértice para todos os outros vértices em um grafo ponderado.

3. **Floyd-Warshall:**
   - Algoritmo de caminho mais curto para todos os pares de vértices.

4. **Kruskal e Prim:**
   - Algoritmos para encontrar a árvore geradora mínima em um grafo ponderado.

5. **Bellman-Ford:**
   - Encontra o caminho mais curto em grafos com arestas de pesos negativos.

### Exemplo de Implementação em Java

Abaixo está um exemplo básico de implementação de um grafo em Java com funções para adicionar vértices e arestas, além de exibir o grafo:

```java
import java.util.*;

class Graph {
    private Map<Integer, List<Integer>> adjList;

    public Graph() {
        adjList = new HashMap<>();
    }

    // Função para adicionar um vértice ao grafo
    public void addVertex(int vertex) {
        adjList.putIfAbsent(vertex, new ArrayList<>());
    }

    // Função para adicionar uma aresta ao grafo
    public void addEdge(int source, int destination) {
        adjList.putIfAbsent(source, new ArrayList<>());
        adjList.putIfAbsent(destination, new ArrayList<>());
        adjList.get(source).add(destination);
        adjList.get(destination).add(source); // Para grafo não-direcionado
    }

    // Função para exibir o grafo
    public void printGraph() {
        for (int vertex : adjList.keySet()) {
            System.out.print(vertex + " -> ");
            for (int neighbor : adjList.get(vertex)) {
                System.out.print(neighbor + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Graph graph = new Graph();

        // Adiciona vértices
        graph.addVertex(1);
        graph.addVertex(2);
        graph.addVertex(3);
        graph.addVertex(4);

        // Adiciona arestas
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(2, 4);
        graph.addEdge(3, 4);

        // Exibe o grafo
        System.out.println("Grafo:");
        graph.printGraph();
    }
}
```

Este exemplo cria um grafo simples, adiciona vértices e arestas, e então imprime a estrutura do grafo.
"""
